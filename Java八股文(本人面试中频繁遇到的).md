# Java 八股文（命中率 100%）

---

## 一、Java 基础

### 1、Java 集合

Java 中的集合总体上分为两大派系，分别是 Collection 接口代表的单列集合，和 Map 接口代表的双列集合。

其中 Collection 接口下又衍生出了 List 接口代表的有序、可重复的集合，和 Set 接口代表的无序、不可重复的集合。

然后常用的实现类有 List 接口下的 ArrayList、LinkedList 和 Set 接口下的 HashSet、TreeSet，还有 Map 接口下的 HashMap、TreeMap 等等。

### 2、ArrayList 和 LinkedList 的区别

首先它们的底层数据结构不同，ArrayList 底层是数组实现的，而 LinkedList 底层是双向链表实现的。

也正是由于它们的底层数据结构不同，导致它们的应用场景也不同，像 ArrayList 它的随机访问性能比较高，就适合做查询操作，而 LinkedList 它在任意位置的插入和删除的效率比较高，就适合做频繁的插入和删除操作。

### 3、ArrayList 的扩容机制

ArrayList 内部通过一个数组存储元素，当我们采用空参构造初始化一个 ArrayList 时，这个数组默认是空的，当第一次添加元素时会扩容到 10，所以我们也经常说 ArrayList 的默认初始容量是 10。

后续添加元素时，都会先判断当前数组容量是否足够，如果不够，就会发生扩容，扩容的规则是计算一个新的容量，等于原来容量的 1.5 倍，如果新容量还不够，比如我们一次添加了多个元素，那就需要多少扩容多少。然后根据新容量创建一个新数组，并把原来数组中的元素拷贝过去。

### 4、HashMap 底层的数据结构

HashMap 的底层在 JDK8 之前是数组 + 链表实现的，也就是通过拉链法解决哈希冲突。然后在 JDK8 之后改成了数组 + 链表 + 红黑树，来解决由于链表过长导致的查询效率降低的问题。

数组的默认初始大小为 16，默认加载因子为 0.75，当链表长度超过阈值（默认为 8）且数组长度大于等于 64 时，链表就会转为红黑树。

### 5、HashMap 和 HashTable 的区别

首先，HashMap 不是线程安全的，而 HashTable 是线程安全的，因为它的相关方法都加了 synchronized 对象锁。

其次，HashMap 是允许键和值为 null 的，而 HashTable 不允许。

## 二、JVM 基础

### 1、JVM 的内存模型

JVM 的内存模型也叫运行时数据区，就是 JVM 在执行 Java 程序时使用到的内存空间。

它总体上可以分为两部分，分别是线程私有的和线程共享的。线程私有的区域包括程序计数器、Java 虚拟机栈和本地方法栈，Java 虚拟机栈中记录了方法调用的顺序，并通过一个个栈帧来存储方法执行时所需的内存空间，栈帧中又包含局部变量表、操作数栈等。然后线程共享的区域包括堆和方法区，堆用来存储对象实例，方法区用来存储类的基本信息。

### 2、双亲委派模型

Java 中类的加载是由类加载器来完成的，而类加载器不止一个，它们按照层级关系由上到下分别是：启动类加载器、扩展类加载器、应用程序类加载器和自定义类加载器。

而双亲委派模型描述的就是一个类到底应该由哪个类加载去加载。具体的规则是当一个类加载器收到加载请求后，会先将该请求委派给它的父类加载器，只有当父类加载器表示该加载请求不在它的职责范围内时，子类加载器才会尝试自己加载。

双亲委派模型的好处在于：可以保证 Java 核心类的安全，确保它只由启动类加载器加载。而且还可以避免类的重复加载。

### 3、类加载过程

一个类的加载过程宏观上可以分为加载、链接和初始化三个阶段，其中链接又分为验证、准备和解析三个阶段。

首先加载阶段就是由 JVM 的类加载器将字节码文件加载到内存，并把这个字节码文件所表示的静态存储结构转换为方法区中的运行时数据结构，同时在堆中创建一个该类的 Class 对象，作为方法区中这个类的各种数据的访问入口。

链接阶段中的验证阶段就是验证字节码文件是否符合规范，准备阶段就是为类的静态变量分配内存，并设置默认初始值，解析阶段就是将方法区中的运行时常量池中的符号引用替换为直接引用。

初始化阶段会执行类的构造器方法 clinit()，这个方法是由编译器收集类中静态变量的赋值动作和静态代码块中的语句，然后合并产生的。所以初始化阶段后，类的静态变量会被赋上我们给它设置的值。

## 三、Java 并发编程

### 1、 Java 中创建线程的四种方式

Java 中创建线程有四种方式，分别是：

- 继承 Thread 类并重写其 run 方法
- 实现 Runnable 接口，然后将该 Runnable 对象传递给 Thread 类的构造器
- 实现 Callable 接口，然后把它包装进一个 FutureTask 对象传给 Thread 类的构造器
- 使用线程池来创建和管理线程

### 2、Java 中线程的六种状态

Java 的 Thread 类中有一个枚举类定义了 Java 线程的六种状态，分别是：

- New：线程刚刚创建，但还没有调用 start 方法来启动
- Runnable：处于就绪和正在运行状态的线程
- Blocked：线程在等待锁
- Waiting：线程正在等待另一个线程执行特定操作
- Timed_Waiting：计时等待
- Terminated：终止状态

### 3、线程安全问题及其解决

线程安全问题有三类，分别是：原子性、可见性和有序性问题。

通过 synchronized 等锁机制可以解决原子性、可见性和有序性问题，通过 volatile 可以解决可见性和有序性问题，但是不能解决原子性问题。 

### 4、Java 中有哪些常用的锁

首先是 synchronized 关键字，也叫对象锁，我们在使用 synchronized 时通常会指定一个对象作为锁，线程在进入 synchronized 代码块时必须先获取该对象关联的锁，离开代码块时也会自动释放锁。

其次是 JUC 包下的 ReentrantLock，相比于 synchronized，它提供了更高级的锁功能，比如支持在获取锁时设置超时时间、支持多个条件变量来进行线程间的通信，还可以用来实现公平锁等等。

除此之外，还有 ReadWriteLock 读写锁，允许多个读取者，但只允许一个写入者，适用于读多写少这种场景。还有一些原子类中用到的这种 CAS 乐观锁，看似没有加锁，其实是在 CPU 指令层面实现的一种硬件锁。

### 5、synchronized 和 ReentrantLock 的区别

首先它们的底层实现不一样，synchronized 是通过对象关联的操作系统层面的监视器锁实现的，而 ReentrantLock 底层是基于 AQS 实现的。

其次它们加锁解锁的方式也不同，synchronized 是在进入和离开同步代码块时自动加锁和解锁的，而 ReentrantLock 需要我们调用方法手动加锁和解锁。

然后它们支持的功能也不同，ReentrantLock 的功能更丰富，它支持中断、支持在获取锁时设置超时时间、支持多个条件变量来进行线程间的通信等等。

还有 synchronized 是非公平锁，而 ReentrantLock 既可以实现公平锁，也可以实现非公平锁。

### 6、JUC 包下常用的类

JUC 包下常用的类大致可以分为三类：

第一类是线程安全相关的。比如常用的锁，像 ReentrantLock、ReadWriteLock。还有线程安全的集合，像 ConcurrentHashMap、CopyOnWriteArrayList。还有一些原子类，像 AtomicInteger、AtomicReference 等。还有一个用来实现线程隔离的类 ThreadLocal。

第二类就是线程池相关的。比如 ThreadPoolExecutor，这是最核心的线程池类，用来创建和管理线程池，通过它可以灵活地配置线程池的参数以满足不同的并发处理需求。还有 Executors，这是一个线程池工厂类，提供了一系列静态方法用来创建不同类型的线程池，方便我们快速地创建线程池。

第三类就是线程通信相关的。像 CountDownLatch、CyclicBarrier、Seamphore 等。

### 7、ThreadLocal 的作用、原理和问题

ThreadLocal 它是 Java 中解决线程安全问题的一种机制，通过它可以为每个线程设置独立的线程局部变量，这样就防止因为线程共享某个变量所带来的线程安全问题。除此之外，通过它还可以很方便地在线程内部进行参数的传递。

ThreadLocal 的实现依赖于 Thread 类中的 ThreadLocalMap 字段，ThreadLocalMap 是线程独立的，即每个线程都有各自的 ThreadLocalMap 实例。我们通过 ThreadLocal 的 set 方法为线程设置局部变量时，其实就是以当前的 ThreadLocal 为 key，我们设置的值为 value，然后将其存入当前线程的 ThreadLocalMap 中，获取的时候也是同理，以 ThreadLocal 为 key，从当前线程的 ThreadLocalMap 中把对应的值取出来。

使用 ThreadLocal 需要注意一个内存泄漏的问题。因为在我们的程序中，线程通常是基于线程池进行复用的，如果我们不及时地清除线程局部变量的话，它会一直存储在当前线程的 ThreadLocalMap 中。解决方法有两个：一个是将 ThreadLocal 实例设置为静态的，这样它就是全局唯一的，当我们下次再进入先前的线程时，依然可以通过 ThreadLocal 变量获取到先前设置的值，即我们没有丢失对线程局部变量的控制权；另一个更好的方法就是在每个线程执行完业务代码后，手动调用 ThreadLocal 的 remove 方法释放掉对应的线程局部变量。

### 8、线程池的核心参数

线程池的核心参数其实就是我们 new ThreadPoolExecutor 时需要指定的那几个参数，它们分别是：

- 核心线程数
- 最大线程数
- 非核心线程的最大空闲时间
- 阻塞队列
- 线程工厂
- 拒绝策略

### 9、线程池的正确创建

首先有个 Executors 类，这是一个线程池工厂类，它提供了一系列静态方法用来创建不同类型的线程池，方便我们快速地创建线程池。比如：

- FixedThreadPool：固定线程数的线程池，即核心线程数和最大线程数相等
- CachedThreadPool：线程数不固定的线程池，它的线程数几乎可以无限增大

但是不推荐！通常我们会根据实际应用场景手动 new ThreadPoolExecutor 来创建线程池，这样可以更灵活地配置线程池的核心参数。比如：

- CPU 密集型的任务：核心线程数要和 CPU 核心数相当，比如设置成 CPU 核心数 + 1
- IO 密集型任务：核心线程数可以设置为 CPU 核心数的 2 倍，因为线程绝大部分时间用不到 CPU

### 10、线程池的工作流程

当我们提交一个任务给线程池时，线程池首先判断核心线程数有没有满，如果没满，就创建一个核心线程来执行任务。如果核心线程数已经满了，就将当前任务加入到阻塞队列。如果队列也满了，就会创建非核心线程来充当临时工去执行任务。随着任务不断添加，如果线程池中的所有线程数加起来已经达到最大线程数时，就会触发拒绝策略。常见的拒绝策略有：

- AbortPolicy：直接抛出异常
- DiscardPolicy：直接丢弃当前任务
- DiscardOldestPolicy：丢弃阻塞队列中排队最久的那一个任务
- CallerRunsPolicy：使用线程池的调用者所在的线程去执行任务
- 自定义拒绝策略（实现 RejectedExecutionHandler 接口）

### 11、实现一个单例模式

首先私有化构造方法，不允许外部随意创建该类的对象。

然后对外提供一个获取该类实例的方法，并通过 double check 检查该类是否已经存在实例。

实例的引用要通过 volatile 修饰，这是为了防止`instance = new Singleton();`这行代码由于指令重排序导致将一个尚未完全初始化的对象引用赋值给了 instance 变量。

```java
public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

## 四、MySQL

### 1、MySQL 的存储引擎

MySQL 常见的存储引擎有 InnoDB、MyISAM 和 Memory 三种。其中 InnoDB 是 MySQL 目前默认的存储引擎。之所以选择 InnoDB 作为默认的存储引擎，是因为它支持事务、行级锁以及外键约束，具有良好的数据一致性和并发性能。

### 2、MySQL 的索引

索引是 MySQL 中用来提高数据查询效率的一种数据结构。像 MySQL 默认的 InnoDB 存储引擎所使用的索引就是 B+树索引，B+树是一种多路平衡查找树，只有叶子节点存放数据，非叶子节点只起到索引的作用，它在数据量很大的情况下层级也不会很高，所以它的查询效率是很高的，而且它的叶子节点之间维护了一条双向链表，在进行范围查询时，也可以很快地定位数据。

### 3、MySQL 中有哪些索引

MySQL 中的索引有好多种类型，可以按照不同的角度进行分类。

* 按照数据结构可分为：B+树索引、Hash 索引 、Full-text 索引。

* 按照物理存储可分为：聚簇索引、非聚簇索引（二级索引、辅助索引）。

* 按照字段特性可分为：主键索引、唯一索引、普通索引、前缀索引。

* 按照字段个数可分为：单列索引、联合索引。

### 4、MySQL 索引失效的场景

MySQL 索引失效的场景大概有以下几种：

- 在 where 条件子句中对索引列使用了函数。
- 或者对索引列进行了表达式计算。
- 或者对索引列进行了左模糊匹配。
- 或者通过 OR 连接了一个没有加索引的字段作为查询条件。
- 还有在使用联合索引时，没有遵循最左匹配原则。
- 除此之外，如果 MySQL 的优化器认为不走索引的效率更高的话，索引也会失效。

### 5、SQL 优化

首先我们要定位到需要进行优化的 SQL，比如通过 MySQL 的慢查询日志可以定位到慢 SQL。

然后可以通过 explain 命令分析这条 SQL 的执行计划。重点看有没有走索引，如果没有走索引，需要考虑是不是我们没有正确的使用索引导致索引失效了，比如不要对索引列进行函数或者表达式计算，使用联合索引时要遵循最左匹配原则。

如果已经走了索引但还是很慢，就要考虑有没有做到覆盖索引，比如尽量不要使用 select *，而是只查询必要的字段，然后针对查询的字段建立联合索引，减少一次回表。

最后如果是因为数据量太大导致的查询效率低的话，还可以考虑分库分表，或者对热点数据加缓存。

### 6、事务的四大特性

事务具有 ACID 四大特性，分别是原子性、一致性、隔离性和持久性。

* 原子性指的是事务中的一组操作是一个不可分割的整体，要么同时成功，要么同时失败。
* 一致性指的是事务操作前后数据库中的数据是一致的。比如转账时，不会出现一个账户的余额减少了，但另一个账户余额没有增加。
* 隔离性是指多个并发的事务之间是相互隔离的，不会互相影响。
* 持久性是指事务一旦提交，它对数据库所做的更改就是永久的，不会因为数据库宕机而消失。

### 7、并发事务的问题以及事务的隔离级别

并发事务有可能导致脏读、不可重复读以及幻读的问题。通过不同的事务隔离级别可以解决这些问题。

事务的隔离级别从低到高分别是读未提交、读已提交、可重复读和串行化。MySQL 默认的事务隔离级别为可重复读。

### 8、MVCC 原理

MVCC，即多版本并发控制，其核心就在于通过维护多个不同版本的数据，以控制在多事务并发情况下，每个事务应该看到哪个版本的数据。

MVCC 是实现读已提交和可重复读这两种事务隔离级别的基础。简单来说，它就是通过 undo log 版本链维护了同一条记录的多个不同的版本，并通过在查询时创建 read view，然后根据 read view 来确定当前事务应该读取 undo log 版本链中的哪一个版本。

读已提交和可重复读的核心区别就在于它们创建 read view 的时机不同，读已提交是在每次执行 select 语句时都创建一个 read view，而可重复读是只在第一次执行 select 语句时创建一个 read view，后续过程中，一直使用这个 read view。

read view 可以理解为当前数据库的一个快照，只不过它不是将当前版本的数据记录下来，而是仅仅记录了四个字段，分别是创建该 read view 的事务 id，当前数据库中正在活跃的事务 id，最小的活跃事务 id 以及下一个事务应分配的 id。同时，MySQL 的每条记录中有两个隐含字段，分别是最后一次改动这条记录的事务 id（trx_id）和指向上一个版本的指针（roll_pointer） 。一个事务在读取某条记录时，会拿当前记录的 trx_id 和 read view 做一个对比，来决定是读取该条记录，还是沿着 undo log 版本链读取之前的记录。

## 五、Redis

### 1、Redis 常用数据类型

Redis 常用的数据类型有 String、Hash、List、Set、ZSet 五种。

这五种数据类型的应用场景有：

- String：缓存 Java 对象、计数器、分布式锁、共享 Session
- Hash：缓存 Java 对象、购物车
- List：消息队列
- Set：点赞数、共同关注
- ZSet：排行榜

Redis 后续版本又推出了 BitMap、HyperLogLog、GEO、Stream 四种数据类型。

### 2、Redis 持久化方式

Redis 持久化方式有三种，分别是 RDB、AOF 以及混合持久化。

RDB 就是直接将内存中的数据以快照的方式写入磁盘文件。Redis 默认开启的就是 RDB 持久化。

AOF 就是将 Redis 的写操作以日志的方式追加到磁盘文件。它与 RDB 不同的就是，一个记录的是实际的数据，一个记录的是命令的日志。

混合持久化就是在 AOF 文件中既有 RDB 快照，也有 AOF 日志。它的实现就是在 AOF 文件重写时，将此时的 RDB 快照写入 AOF 文件的头部，然后在此期间 Redis 发生的写操作会以 AOF 日志的方式追加到 AOF 文件中。

### 3、Redis 集群部署

Redis 有两种集群部署的方式，分别是主从集群和分片集群。

它们的区别在于：主从集群模式下，每个 Redis 节点存储的都是全量的数据，而分片集群模式下，每个 Redis 节点只存储一部分数据。

分片集群模式下，客户端如何确定某个 key 应该存储在哪个 Redis 节点上呢？答案是通过哈希映射。Redis 将存储容量划分为 16384 个哈希槽，由每个节点负责一部分，并在本地维护各节点与哈希槽的映射关系。当客户端要存储或者获取一个 key 时，会根据 key 进行哈希映射，确定所属的槽位，进而确定 key 所属的 Redis 节点。

### 4、缓存的三大问题及其解决

使用 Redis 做缓存时，会有三个问题，分别是：缓存击穿、缓存雪崩、缓存穿透。

缓存击穿是指某个热点 key 过期导致的缓存无法命中的问题。我们可以在发生缓存击穿时加互斥锁，确保只有一个请求去访问数据库并重构缓存；也可以索性不给热点 key 设置过期时间，由我们自己的业务程序决定何时更新缓存。

缓存雪崩是指大量 key 在同一时间过期导致缓存无法命中，进而导致数据库压力飙升的问题。我们可以通过给每个 key 设置不同的过期时间，来确保它们不会在同一时间过期；同时也可以想缓存击穿那样，通过加锁或者不设置过期时间来应对。

缓存穿透是指请求的数据既不在缓存中，也不在数据库中，导致缓存始终无法重构的问题。这通常是由于一些恶意的非法请求导致的，我们首先要在请求到来时做好数据校验，对于非法请求直接拦截；也可以在发生缓存穿透时缓存一个空值或默认值到 Redis 中，确保后续的请求不会直接打到数据库；还可以通过布隆过滤器快速判断数据是否存在于数据库中，如果不存在就没必要再访问数据库了。

### 5、如何保证数据库和缓存的数据一致性

在更新数据时，采用先更新数据库，再删缓存的策略，可以最大程度的保证数据一致性。

## 六、Spring

### 1、Spring 的核心功能

Spring 的核心功能有两点，分别是：IoC 和 AOP。

IoC，即控制反转，就是说 Spring 通过 IoC 容器帮我们接管了程序中所要用到的这些对象，并通过依赖注入维护对象之间的依赖关系，不用我们手动 new 对象了，大大降低了对象之间的耦合性。

AOP，即面向切面编程，可以将一些方法内通用的代码逻辑，也叫横切关注点，抽取出来，然后 Spring 通过动态代理，在需要时对原有方法进行增强，这样可以减少重复代码。

### 2、Spring 事务失效的场景

首先 Spring 的声明式事务是通过动态代理来实现的，我们如果调用的不是代理对象的事务方法，那么事务就是失效。比如：

- 事务加在了非 public 修饰的方法上会失效，因为 Spring 动态代理无法代理这种方法。
- 事务加在了 final 修饰的方法上会失效，因为 Spring 动态代理无法代理这种方法。
- 通过 this 关键字调用事务方法会失效，因为这样绕过了 Spring 生成的代理对象。

还有就是 Spring 的声明式事务默认只对运行时异常进行回滚，如果抛出的异常类型不匹配的话，事务也不会回滚。还有就是在方法内抛出了异常但被我们自己捕获了，事务也不会回滚。

### 3、Spring Boot 的自动装配原理

简单来说，Spring Boot 的自动装配就是基于 Spring 的条件装配和 @EnableAutoConfiguration 注解实现的。

具体的实现其实是，每个起步依赖中都有一份文件（Spring Boot 2.7 版本之前是 spring.factories 文件，2.7 之后是AutoConfiguration.imports 文件），其中定义了一系列的自动配置类。

Spring Boot 项目在启动时会去扫描这些文件并加载这些自动配置类，然后结合 Spring 的条件装配注解来决定是否装配其中定义的 Bean 对象。
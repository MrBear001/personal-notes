# Java 八股文（命中率 100%）

## 一、Java 基础

### 1、Java 集合

Java 中的集合总体上分为两大派系，分别是 Collection 接口代表的单列集合，和 Map 接口代表的双列集合。

其中 Collection 接口下又衍生出了 List 接口代表的有序、可重复的集合，和 Set 接口代表的无序、不可重复的集合。

然后常用的实现类有 List 接口下的 ArrayList、LinkedList 和 Set 接口下的 HashSet、TreeSet，还有 Map 接口下的 HashMap、TreeMap 等等。

### 2、ArrayList 和 LinkedList 的区别

首先它们的底层数据结构不同，ArrayList 底层是数组实现的，而 LinkedList 底层是双向链表实现的。

也正是由于它们的底层数据结构不同，导致它们的应用场景也不同，像 ArrayList 它的随机访问性能比较高，就适合做查询操作，而 LinkedList 它在任意位置的插入和删除的效率比较高，就适合做频繁的插入和删除操作。

### 3、ArrayList 的扩容机制

ArrayList 内部通过一个数组存储元素，当我们采用空参构造初始化一个 ArrayList 时，这个数组默认是空的，当第一次添加元素时会扩容到 10，所以我们也经常说 ArrayList 的默认初始容量是 10。

后续添加元素时，都会先判断当前数组容量是否足够，如果不够，就会发生扩容，扩容的规则是计算一个新的容量，等于原来容量的 1.5 倍，如果新容量还不够，比如我们一次添加了多个元素，那就需要多少扩容多少。然后根据新容量创建一个新数组，并把原来数组中的元素拷贝过去。

### 4、HashMap 底层的数据结构

HashMap 的底层在 JDK8 之前是数组 + 链表实现的，也就是通过拉链法解决哈希冲突。然后在 JDK8 之后改成了数组 + 链表 + 红黑树，来解决由于链表过长导致的查询效率降低的问题。

数组的默认初始大小为 16，默认加载因子为 0.75，当链表长度超过阈值（默认为 8）且数组长度大于等于 64 时，链表就会转为红黑树。

### 5、HashMap 和 HashTable 的区别

首先，HashMap 不是线程安全的，而 HashTable 是线程安全的，因为它的相关方法都加了 synchronized 对象锁。

其次，HashMap 是允许键和值为 null 的，而 HashTable 不允许。

## 二、JVM

### 1、JVM 的内存模型

JVM 的内存模型也叫运行时数据区，就是 JVM 在执行 Java 程序时使用到的内存空间。

它总体上可以分为两部分，分别是线程私有的和线程共享的。线程私有的区域包括程序计数器、Java 虚拟机栈和本地方法栈，Java 虚拟机栈中记录了方法调用的顺序，并通过一个个栈帧来存储方法执行时所需的内存空间，栈帧中又包含局部变量表、操作数栈等。然后线程共享的区域包括堆和方法区，堆用来存储对象实例，方法区用来存储类的基本信息。

### 2、双亲委派模型

Java 中类的加载是由类加载器来完成的，而类加载器不止一个，它们按照层级关系由上到下分别是：启动类加载器、扩展类加载器、应用程序类加载器和自定义类加载器。

而双亲委派模型描述的就是一个类到底应该由哪个类加载去加载。具体的规则是当一个类加载器收到加载请求后，会先将该请求委派给它的父类加载器，只有当父类加载器表示该加载请求不在它的职责范围内时，子类加载器才会尝试自己加载。

双亲委派模型的好处在于：可以保证 Java 核心类的安全，确保它只由启动类加载器加载。而且还可以避免类的重复加载。

### 3、类加载过程

一个类的加载过程宏观上可以分为加载、链接和初始化三个阶段，其中链接又分为验证、准备和解析三个阶段。

首先加载阶段就是由 JVM 的类加载器将字节码文件加载到内存，并把这个字节码文件所表示的静态存储结构转换为方法区中的运行时数据结构，同时在堆中创建一个该类的 Class 对象，作为方法区中这个类的各种数据的访问入口。

链接阶段中的验证阶段就是验证字节码文件是否符合规范，准备阶段就是为类的静态变量分配内存，并设置默认初始值，解析阶段就是将方法区中的运行时常量池中的符号引用替换为直接引用。

初始化阶段会执行类的构造器方法 clinit()，这个方法是由编译器收集类中静态变量的赋值动作和静态代码块中的语句，然后合并产生的。所以初始化阶段后，类的静态变量会被赋上我们给它设置的值。
# MySQL

---

## 1、MySQL 概述

软件的核心是数据，数据如何存储？答案是数据库（DataBase，DB）。数据库是专门用来存储和管理数据的地方。

而 MySQL 则是一款数据库管理系统（DataBase Manage System，DBMS），通过它可以便捷地存储和管理数据。

与 MySQL 交互需要通过一门结构化查询语言（Stuctured Query Languge）来实现，也就是 SQL。如何编写 SQL 是我们学习的重点。

## 2、SQL 基础

SQL 是结构化查询语言，是一种专门操作关系型数据库的语言。SQL 有统一的标准，不同的数据库厂商都遵循这个标准，但是又各自有不同的扩展，所以 SQL 是有方言存在的。在学习 MySQL 时，要重点学习标准的 SQL 写法，同时也要了解 MySQL 特有的 SQL 方言。

### 2.1、SQL 的分类

SQL 根据其作用不同，可以分为以下四类：

* DDL —— 数据定义语言 —— 用来定义数据库对象
* DML —— 数据操作语言 —— 用来对表中的数据进行增删改操作
* DQL —— 数据查询语言 —— 用来对表中的数据进行查询操作
* DCL —— 数据控制语言 —— 用来管理数据库的用户及其权限

### 2.2、DDL

DDL 语句中有与库定义相关的，还有与表定义相关的。

1）库定义相关的语句：

```sql
-- 查询所有数据库
SHOW DATABASES;
-- 创建数据库
CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则];
-- 查询建库语句
SHOW CREATE DATABASE 数据库名;
-- 使用/切换数据库
USE 数据库名;
-- 查询当前使用的数据库
SELECT DATABASE();
-- 删除数据库
DROP DATABASE [IF EXISTS] 数据库名;
```

2）表定义相关的语句：

```sql
-- 查询当前库中的所有表
SHOW TABLES;
-- 创建表
CREATE TABLE [IF NOT EXISTS] 表名 (
	字段1 类型 [约束] [COMMENT 注释],
	字段2 类型 [约束] [COMMENT 注释],
	...
    [表级约束]
) [ENGINE=存储引擎] [DEFAULT CHARSET=字符集] [COLLATE=排序规则] [COMMENT 注释];
-- 查看表结构
DESC 表名;
-- 查询建表语句
SHOW CREATE TABLE 表名;
-- 修改表
ALTER TABLE 表名 ADD 字段名 类型 [约束] [COMMENT 注释]; -- 添加字段
ALTER TABLE 表名 CHANGE 字段名 新字段名 类型 [约束] [COMMENT 注释]; -- 修改字段
ALTER TABLE 表名 DROP 字段名; -- 删除字段
ALTER TABLE 表名 RENAME TO 新表名; -- 重命名表
-- 删除表
DROP TABLE [IF EXISTS] 表名;
```

### 2.3、DML

```sql
-- 新增操作
INSERT INTO 表名 VALUES (值1, 值2, ...); -- 新增时指定所有字段
INSERT INTO 表名 (字段1, 字段2, ...) VALUES (值1, 值2, ...); -- 新增时指定部分字段
INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), ...; -- 批量新增
INSERT INTO 表名 (字段1, 字段2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), ...;
-- 更新操作
UPDATE 表名 SET 字段1 = 值1, 字段2 = 值2, ... [WHERE 条件];
-- 删除操作
DELETE FROM 表名 [WHERE 条件];
```

### 2.4、DQL

DQL 语句是比较复杂的，而且在查询时还分为单表查询和多表查询。我们可以先通过单表查询熟悉 DQL 语句的基本用法，然后再拓展到多表查询。

1）单表查询：

一个比较完整的单表查询的 DQL 语句大概长这样：

```sql
SELECT [DISTINCT] * | 字段1 [AS 别名], 字段2 [AS 别名], ... -- 加DISTINCT表示去重，加AS表示取别名，AS可以省略
FROM 表名 [AS 别名]
[WHERE 条件]
[GROUP BY 字段]
[HAVING 分组后条件]
[ORDER BY 字段 [ASC | DESC]] -- ASC表示升序排序，DESC表示降序排序，默认就是ASC，也可以指定多个排序字段
[LIMIT [起始索引], 查询数量];
```

它的执行顺序为：FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY -> LIMIT

2）多表查询：

多表查询是指同时从多张表中查询数据，它有以下几种形式：

```sql
-- 内连接（只返回两个表中满足连接条件的记录）
SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件;
SELECT 字段列表 FROM 表1, 表2 WHERE 连接条件; -- 隐式的内连接写法
-- 左外连接（返回左表中所有的记录和右表中满足连接条件的记录，右表没有匹配的用 NULL 填充）
SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 连接条件;
-- 右外连接（返回右表中所有的记录和左表中满足连接条件的记录，左表没有匹配的用 NULL 填充，右外连接可以改写成左外连接）
SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 连接条件;
-- 全外连接（MySQL 不支持 FULL OUTER JOIN 全外连接，但可通过 UNION 模拟）
```

## 3、MySQL 的数据类型

我们在建表时需要指定每个字段的数据类型以提高存储效率和节约存储空间。MySQL 中主要提供了数值、字符串和日期时间这三类数据类型。

### 3.1、数值类型

整数：TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT

所有的整数类型都可以添加 UNSIGNED 关键字，表示无符号整数，这样可以将正数的存储范围扩大一倍。

浮点数：FLOAT、DOUBLE、DECIMAL

### 3.2、字符串类型

短字符串：CHAR、VARCHAR

长文本：TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT

### 3.3、日期时间类型

DATE、TIME、YEAR、DATETIME、TIMESTAMP

## 4、MySQL 的函数

Excel 表格提供有大量的函数便于我们进行统计计算，而 MySQL 也提供了大量内置函数，用于处理字符串、数值、日期时间、聚合操作等，常见的函数如下。

### 4.1、字符串函数

```sql
# CONCAT 连接字符串
SELECT CONCAT('Hello', ' ', 'World'); # 'Hello World'
# TRIM 去除字符串首尾的空格
SELECT TRIM('  hello  '); # 'hello'
```

### 4.2、数值函数

```sql
# ABS 取绝对值
SELECT ABS(-10); # 10
# ROUND 四舍五入保留几位小数
SELECT ROUND(123.456, 2); # 123.46
```

### 4.3、日期时间函数

```sql
# NOW 返回当前时间
SELECT NOW(); # 如 '2025-12-08 15:50:00'
# DATEDIFF 计算两个日期相差的天数
SELECT DATEDIFF('2025-12-10', '2025-12-08'); # 2
```

### 4.4、聚合函数

```sql
# COUNT 统计数量
SELECT COUNT(*) FROM users;
# SUM 求和
SELECT SUM(salary) FROM employees;
# AVG 求平均值
SELECT AVG(score) FROM students;
# MAX MIN 获取最大最小值
SELECT MAX(price), MIN(price) FROM products;
```

### 4.5、流程控制函数

```sql
# IF 条件判断
SELECT IF(1 > 0, 'Yes', 'No'); # 'Yes'
# CASE 多条件判断
SELECT 
  name,
  CASE 
    WHEN score >= 90 THEN 'A'
    WHEN score >= 80 THEN 'B'
    ELSE 'C'
  END AS grade
FROM students;
```

## 5、MySQL 的约束

我们在建表时可以给每个字段加上约束，约束是作用在字段上的规则，通过它可以保证数据库中数据的正确性、有效性和完整性。

MySQL 中主要提供了以下几种约束：

| 约束       | 关键字         | 作用                                                         |
| ---------- | -------------- | ------------------------------------------------------------ |
| 主键约束   | PRIMARY KEY    | 确保该字段是行记录的唯一标识，一个表只能有一个主键约束       |
| 自增约束   | AUTO_INCREMENT | 确保该字段是自增且唯一的，一个表只能有一个自增约束并且只能用于整数列 |
| 唯一约束   | UNIQUE         | 确保该字段是唯一的，不会重复的                               |
| 非空约束   | NOT NULL       | 确保该字段是不为空的                                         |
| 检查约束   | CHECK          | 确保该字段满足自定义的规则                                   |
| 外键约束   | FOREIGN KEY    | 确保该字段引用的是另一张表中存在的值                         |
| 默认值约束 | DEFAULT        | 确保该字段如果不指定值的话，会有一个默认值                   |

## 6、MySQL 的事务

### 6.1、什么是事务

事务是一组操作的集合，这些操作要么同时成功，要么同时失败。

### 6.2、事务的使用

默认情况下，MySQL 是自动提交每条 SQL 语句的。要想使用事务，需要显式地控制：

```sql
-- 开启事务（也可以用 START TRANSACTION）
BEGIN;

-- 执行一系列 SQL 操作
UPDATE accounts SET balance = balance - 100 WHERE user_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE user_id = 2;

-- 如果一切正常，提交事务
COMMIT;

-- 如果出错，回滚事务
ROLLBACK;
```

### 6.3、事务的四大特性

事务具有 ACID 四大特性，分别是原子性、一致性、隔离性和持久性。

* 原子性：指的是事务中的一组操作是一个不可分割的整体，要么同时成功，要么同时失败。
* 一致性：指的是事务操作前后数据库中的数据是一致的。比如转账时，不会出现一个账户余额减少了，但另一个账户余额没有增加。
* 隔离性：指的是多个并发的事务之间是相互隔离的，彼此之间互不干扰。
* 持久性：指的是事务一旦提交，它对数据库所做的更改就是永久的，不会因为数据库宕机而丢失。

### 6.4、并发事务的问题

并发事务有可能会导致脏读、不可重复读和幻读的问题。

* 脏读：指的是一个事务读到了另一个事务未提交的数据。
* 不可重复读：指的是一个事务多次读取同一条数据，出现前后两次结果不一致的现象。
* 幻读：指的是一个事务多次查询某个符合查询条件的记录数量，出现前后两次数量不一致的现象。

通过不同的事务隔离级别可以解决上述这些问题。

### 6.5、事务的隔离级别

事务的隔离级别从低到高分别是读未提交、读已提交、可重复读和串行化。MySQL 默认的事务隔离级别为可重复读。

* 读未提交：指一个事务可以读到其他事务未提交的数据。在这种隔离级别下，有可能导致脏读、不可重复读和幻读的问题。
* 读已提交：指一个事务只能读到其他事务已提交的数据。在这种隔离级别下，有可能导致不可重复读和幻读的问题。
* 可重复读：指一个事务在执行期间读到的数据始终和该事务启动时读到的数据一致。在这种隔离级别下，有可能导致幻读的问题。
* 串行化：指多个事务之间是串行执行的。在这种隔离级别下，不会产生任何并发事务问题。

### 6.6、事务隔离的实现原理

MySQL 是怎么实现事务的可重复读的隔离级别的呢？答案是 MVCC。事实上，MVCC 是实现读已提交和可重复读这两种事务隔离级别的基础。

MVCC，即多版本并发控制。其核心就在于通过维护多个不同版本的数据，以控制在多事务并发的情况下，每个事务应该看到哪个版本的数据。

简单来说，它就是通过 undo log 版本链维护了同一条记录的多个不同的版本，并通过在查询时创建 read view，然后根据 read view 来确定当前事务应该读取 undo log 版本链中的哪一个版本。

读已提交和可重复读的核心区别就在于它们创建 read view 的时机不同，读已提交是在每次执行 select 语句时都创建一个 read view，而可重复读是只在第一次执行 select 语句时创建一个 read view，后续过程中，一直使用这个 read view。

read view 可以理解为当前数据库的一个快照，只不过它不是将当前版本的数据记录下来，而是仅仅记录了四个字段，分别是创建该 read view 的事务 id，当前数据库中正在活跃的事务 id，最小的活跃事务 id 以及下一个事务应分配的 id。同时，MySQL 的每条记录中有两个隐藏字段，分别是最后一次改动这条记录的事务 id（trx_id）和指向上一个版本的指针（roll_pointer） 。一个事务在读取某条记录时，会拿当前记录的 trx_id 和 read view 做一个对比，来决定是读取该条记录，还是沿着 undo log 版本链读取之前的记录。

---

## 7、MySQL 的架构

MySQL 总体上可以分为服务层和存储引擎层两层架构。服务层主要负责与客户端建立连接、分析和执行 SQL，存储引擎层则负责数据的具体存储。

### 7.1、服务层

MySQL 服务层主要包括以下组件：

* 连接器：负责与客户端建立连接、校验用户身份等。
* 解析器：负责对 SQL 语句进行词法分析、语法分析，判断 SQL语句有没有语法错误。
* 预处理器：负责检查 SQL 语句中的表或字段是否存在，包括将 SELECT 语句中的 * 替换为具体的字段列表。
* 优化器：负责确定 SQL 语句的执行计划。
* 执行器：负责根据 SQL 语句的执行计划与存储引擎交互。

### 7.2、存储引擎层

MySQL 的存储引擎层决定了数据在底层如何存储。

MySQL 支持多种存储引擎，常见的有 InnoDB、MyISAM 和 Memory 三种。其中 InnoDB 是 MySQL 5.5 版本之后默认的存储引擎。之所以选择 InnoDB 作为默认的存储引擎，是因为它支持事务、行级锁以及外键约束，具有良好的数据一致性和并发性能。

存储引擎是基于表的，我们可以在创建表时指定存储引擎。采用 InnoDB 存储引擎的表在磁盘上都对应一份独占表空间文件（.ibd文件）。

## 8、MySQL 的索引

### 8.1、什么是索引

索引是数据库中用来提高数据查询效率的一种数据结构。

### 8.2、索引的数据结构

MySQL 默认使用 InnoDB 存储引擎，它的索引结构是基于 B+ 树实现的。

MySQL 的 B+ 树索引的数据结构是一种多路平衡查找树，只有叶子节点存放数据，非叶子节点只起到索引的作用，它在数据量很大的情况下层级也不会很高，所以它的查询效率是很高的。而且它的叶子节点之间维护了一条双向链表，在进行范围查询时，也可以很快地定位数据。

### 8.3、索引的分类

MySQL 中有多种索引类型，常见的有：主键索引、唯一索引、普通索引、前缀索引等。

其中，主键索引比较特殊。它是一种聚簇索引，其他的索引都是非聚簇索引，或者叫二级索引。聚簇索引是指在物理存储上，数据和索引是一起存储的。

索引不仅可以针对单个字段建立，还可以针对多个字段建立联合索引。

### 8.4、索引的使用

```sql
-- 创建普通索引
CREATE INDEX idx_email ON users(email);

-- 创建唯一索引
CREATE UNIQUE INDEX idx_username ON users(username);

-- 建表时指定
CREATE TABLE users (
    id INT PRIMARY KEY,
    email VARCHAR(100),
    INDEX idx_email (email)
);

-- 查看索引
SHOW INDEX FROM users;

-- 删除索引
DROP INDEX idx_email ON users;
```

### 8.5、索引失效的场景

MySQL 索引失效的场景大概有以下几种：

- 在 where 条件子句中对索引列使用了函数。
- 或者对索引列进行了表达式计算。
- 或者对索引列进行了左模糊匹配。
- 或者通过 OR 连接了一个没有加索引的字段作为查询条件。
- 还有在使用联合索引时，没有遵循最左匹配原则。
- 除此之外，如果 MySQL 的优化器认为不走索引的效率更高的话，索引也会失效。

### 8.6、SQL 优化

首先我们要定位到需要进行优化的 SQL，比如通过 MySQL 的慢查询日志可以定位到慢 SQL。

然后可以通过 explain 命令分析这条 SQL 的执行计划。重点看有没有走索引，如果没有走索引，需要考虑是不是我们没有正确的使用索引导致索引失效了，比如不要对索引列进行函数或者表达式计算，使用联合索引时要遵循最左匹配原则。

如果已经走了索引但还是很慢，就要考虑有没有做到覆盖索引，比如尽量不要使用 select *，而是只查询必要的字段，然后针对查询的字段建立联合索引，减少一次回表。

最后如果是因为数据量太大导致的查询效率低的话，还可以考虑分库分表，或者对热点数据加缓存。

